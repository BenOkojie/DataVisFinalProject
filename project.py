# -*- coding: utf-8 -*-
"""Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12wsp-EXjykKrL_LGjNIGZYPSBNEzN7Ft
"""
import pandas as pd
import json
import dash
from dash import dcc, html, Output, Input
import plotly.express as px
import plotly.graph_objects as go
import difflib

# Cleaning the data
df = pd.read_csv('project.csv')
occupation = df[['Geography']]
columns = list(df.columns)
locations = []
i = 1
location_data = {}
count = 1
places=[]
print(len(columns))
while i < len(columns):
    loc_name = columns[i]
    t = str(count)
    n = len(loc_name)-(len(t)+2)
    loc_name = loc_name[:n]
    places.append(loc_name)
    print(loc_name)
    if pd.isna(loc_name):
        i += 3
        continue
    sub_df = df.iloc[:, i:i+3].copy()
    sub_df.columns = [loc_name, 'Men', 'Women']
    location_data[loc_name] = sub_df
    i += 3
    count+=1
highestNOC=[]
NOCindex={}
wres = []
mres = []
for i in range(8,len(occupation)):
  text = occupation.iloc[i].values[0]
  number_str, label = text.split(" ", 1)
  if len(number_str)==1:
    number = int(number_str)
    print(number)
    if number > 0 and number<10:
      print("check")
      highestNOC.append(text)
      NOCindex[text]=i
with open('canada.geojson') as f:
    canada_geojson = json.load(f)

occupation.head()

nurseprompt= "3130 Nursing and allied health professionals"
firefighter = "42101 Firefighters"
police = "42100 Police officers (except commissioned)"
def sum_vals(p1,p2,p3,dt):
  nindex = occupation.index[occupation['Geography'] == p1][0]
  findex = occupation.index[occupation['Geography'] == p2][0]
  pindex = occupation.index[occupation['Geography'] == p3][0]
  normalizer = "Total - Occupation - Unit group - National Occupational Classification (NOC) 2021 12"
  normalindex = occupation.index[occupation['Geography'] == normalizer][0]
  res = []
  p1arr = []
  p2arr = []
  p3arr = []
  if dt == "canada":
    canada_values = location_data[places[0]].iloc[nindex]
    nvalue = canada_values.replace(',', '', regex=True).astype(int)
    nvalue = nvalue.iloc[0]
    canada_values = location_data[places[0]].iloc[findex]
    fvalue = canada_values.replace(',', '', regex=True).astype(int)
    fvalue = fvalue.iloc[0]
    canada_values = location_data[places[0]].iloc[pindex]
    pvalue = canada_values.replace(',', '', regex=True).astype(int)
    pvalue = pvalue.iloc[0]
    total = nvalue + fvalue + pvalue
    return total,nvalue,fvalue,pvalue
  for i in range(1,len(places)):
    canada_values = location_data[places[i]].iloc[normalindex]
    normalvalue = canada_values.replace(',', '', regex=True).astype(int)
    normalvalue = normalvalue.iloc[0]
    canada_values = location_data[places[i]].iloc[nindex]
    nvalue = canada_values.replace(',', '', regex=True).astype(int)
    nvalue = nvalue.iloc[0]
    canada_values = location_data[places[i]].iloc[findex]
    fvalue = canada_values.replace(',', '', regex=True).astype(int)
    fvalue = fvalue.iloc[0]
    canada_values = location_data[places[i]].iloc[pindex]
    pvalue = canada_values.replace(',', '', regex=True).astype(int)
    pvalue = pvalue.iloc[0]
    if dt =="all":
      total = nvalue + fvalue + pvalue
      res.append(total)
      p1arr.append(nvalue)
      p2arr.append(fvalue)
      p3arr.append(pvalue)
    else:
      if dt =="e":
        total = normalvalue/nvalue + normalvalue/fvalue + normalvalue/pvalue

      if dt=="p1":
        total = normalvalue/nvalue

      if dt=="p2":
        total = normalvalue/fvalue

      if dt=="p3":
        total = normalvalue/pvalue

      res.append(total)
  if dt =="all":
    return res,p1arr,p2arr,p3arr
  else:
    return res


def q2(industry):
  mres=[]
  wres=[]
  for i in range(1,len(places)):
    canada_values = location_data[places[i]].iloc[NOCindex[industry]]
    nvalue = canada_values.replace(',', '', regex=True).astype(int)

    man = nvalue.iloc[1]
    woman = nvalue.iloc[2]
    mres.append(man)
    wres.append(woman)
  return mres,wres
mc,wc = q2(highestNOC[0])
print(len(mc))
def q3():
  province_names = places[1:]
  province_codes = ['NL', 'PE', 'NS', 'NB', 'QC', 'ON', 'MB', 'SK', 'AB', 'BC', 'YT', 'NT', 'NU']
  elec = "21310 Electrical and electronics engineers"
  mech ="21301 Mechanical engineers"
  comp = "21311 Computer engineers (except software engineers and designers)"
  cpower,ccomp,cmech,celec = sum_vals(comp,mech,elec,"canada")
  mpower, computer, mechanical, electrical = sum_vals(comp,mech,elec,"all")
  provdata = pd.DataFrame({
    'code': province_codes,
    'province': province_names,
    'value': mpower,
    'computer': computer,
    'mechanical': mechanical,
    'electrical': electrical
  })
  cdata = pd.DataFrame({

    'value': [cpower],
    'computer': [ccomp],
    'mechanical': [cmech],
    'electrical': [celec]
    })

  return provdata,cdata
def q4(province):
   total = []
   for i in range(len(highestNOC)):
      canada_values = location_data[province].iloc[NOCindex[highestNOC[i]]]
      nvalue = canada_values.replace(',', '', regex=True).astype(int)
      t = nvalue.iloc[0]
      woman = nvalue.iloc[2]
      total.append(t)
   return total
l = q4("Ontario")
print(l)

app = dash.Dash(__name__)
server = app.server
label_map = {
    'e': 'Total Essentials',
    'p1': 'Nurses',
    'p2': 'Firefighters',
    'p3': 'Police',

}
provdata,canadadata = q3()
app.layout = html.Div([
    html.Div([
        html.H1("The proportion of essential workers to all employed people in region."),
        dcc.RadioItems(
            id='category-selector',
            options=[
                {'label': 'Total Essentials', 'value': 'e'},
                {'label': 'Nurses', 'value': 'p1'},
                {'label': 'Firefighters', 'value': 'p2'},
                {'label': 'Police', 'value': 'p3'}
            ],
            value='e',
            labelStyle={'display': 'block', 'margin-bottom': '10px'}
        )
    ], style={'width': '20%', 'display': 'inline-block', 'verticalAlign': 'top', 'padding': '20px'}),

    html.Div([
        dcc.Graph(id='bar-graph')
    ], style={'width': '75%', 'display': 'inline-block'}),
    html.Div([
        html.H1("Province gender difference per industry"),
        dcc.Dropdown(
            id='industry-dropdown',
            options=[{'label': ind, 'value': ind} for ind in highestNOC],
            value = highestNOC[0],
            clearable=False,
            style={'width': '100%', 'margin':'20px'}
        )
    ], style={'margin': '20px'}),

    html.Div(id='pie-charts-container'),

    html.Div([
    html.Div([
        html.H1("Electric vehicles potential factory"),
        dcc.Graph(
    id='canada-map',
    figure=px.choropleth(
        provdata,
        geojson=canada_geojson,
        locations='province',
        height = 700,
        width = 1000,
        color='value',
        color_continuous_scale='Blues',
        featureidkey="properties.name",
        scope='north america'
    ).update_geos(fitbounds="locations", visible=False).update_layout(margin={"r":0,"t":30,"l":0,"b":0})
)]),
        html.Div([
            dcc.Graph(id='engineer-pie'),
            html.Div(id='province-info', style={
                'fontSize': '18px',
                'marginTop': '20px',
                'lineHeight': '2'
            })
        ], style={'width': '40vw', 'padding': '20px'})
    ], style={'display': 'flex', 'justifyContent': 'space-between'}),
    html.Div([
    html.H1("Industry Workforce Per Region Bubble Chart"),

    html.Div([
        dcc.Input(
            id='place-input',
            type='text',
            placeholder='Enter a province or territory (e.g. Ontario)',
            debounce=True,
            style={'width': '300px'}
        ),
        html.Div(id='error-message', style={'color': 'red', 'marginTop': '10px'})
    ], style={'marginBottom': '20px'}),

    dcc.Graph(id='bubble-chart')
])
])
@app.callback(
    Output('engineer-pie', 'figure'),
    Output('province-info', 'children'),
    Input('canada-map', 'clickData')
)


def update_sidebar(clickData):
    if not clickData:
      fig = go.Figure(data=[go.Pie(
        labels=['Computer Engineers', 'Mechanical Engineers', 'Electrical Engineers'],
        values=[canadadata['computer'].values[0], canadadata['mechanical'].values[0], canadadata['electrical'].values[0]],
        marker=dict(colors=['#1f77b4', '#ff7f0e', '#2ca02c']),
    )])
      fig.update_layout(title=f"Click a province to see details", height=350)
      info = html.Div([
        html.H1(f"Canada"),
        html.H2(f"Total Manpower: {canadadata['value'].values[0]}"),
        html.Div(f"Computer Engineers: {canadadata['computer'].values[0]}"),
        html.Div(f"Mechanical Engineers: {canadadata['mechanical'].values[0]}"),
        html.Div(f"Electrical Engineers: {canadadata['electrical'].values[0]}")
    ])
      return fig, info

    province = clickData['points'][0]['location']
    row = provdata[provdata['province'] == province].iloc[0]
    fig = go.Figure(data=[go.Pie(
        labels=['Computer Engineers', 'Mechanical Engineers', 'Electrical Engineers'],
        values=[row['computer'], row['mechanical'], row['electrical']],
        marker=dict(colors=['#1f77b4', '#ff7f0e', '#2ca02c']),

    )])
    fig.update_layout(title=f"{row['province']} - Engineer Breakdown", height=350)

    info = html.Div([
        html.H1(f"{row['province']}"),
        html.H2(f"Total Manpower: {row['value']}"),
        html.Div(f"Computer Engineers: {row['computer']}"),
        html.Div(f"Mechanical Engineers: {row['mechanical']}"),
        html.Div(f"Electrical Engineers: {row['electrical']}")
    ])

    return fig, info
@app.callback(
    Output('pie-charts-container', 'children'),
    Input('industry-dropdown', 'value')
)
def update_pie_charts(selected_industry):
    men_counts, women_counts = q2(selected_industry)
    pie_charts = []
    reg = places[1:]
    for i in range(len(reg)):
        fig = go.Figure(data=[
            go.Pie(
                labels=['Men', 'Women'],
                values=[men_counts[i], women_counts[i]],
                marker=dict(colors=['#1f77b4', '#ff69b4'])
            )
        ])
        fig.update_layout(
            title_text=reg[i],
            height=250,
            width=250,
            margin=dict(t=30, b=10, l=10, r=10)
        )

        pie_charts.append(html.Div([
            dcc.Graph(figure=fig)
        ], style={'display': 'inline-block', 'margin': '10px'}))

    return pie_charts
@app.callback(
    Output('bar-graph', 'figure'),
    Input('category-selector', 'value')
)
def update_graph(selected):

    values = sum_vals(nurseprompt, firefighter, police, selected)


    x_labels = places[1:]
    fig = go.Figure(data=[
        go.Bar(x=x_labels, y=values)
    ])
    fig.update_layout(
        title="the proportion of essential workers all employed people in region.",
        xaxis_title="Province/Territory",
        yaxis_title="Work Population",
        height=700
    )
    return fig
@app.callback(
    Output('bubble-chart', 'figure'),
    Output('error-message', 'children'),
    Input('place-input', 'value')
)

def update_bubble_chart(place):
    if not place:

        place = 'Ontario'

    matched = difflib.get_close_matches(place, places, n=1, cutoff=0.6)

    if not matched:
        return dash.no_update, f"'{place}' is not recognized. Please try a different name."

    best_match = matched[0]


    counts = q4(best_match)

    df = pd.DataFrame({
        'industry': highestNOC,
        'workers': counts
    })

    fig = px.scatter(
        df,
        x='industry',
        y='workers',
        size='workers',
        color='industry',
        title=f'Industry Workforce in {best_match}',
        labels={'workers': 'Worker Population'},
        height=800
    )

    fig.update_traces(mode='markers', marker=dict(sizemode='area', sizeref=2.*max(df['workers'])/(100**2), line_width=2))

    return fig, ""

if __name__ == '__main__':
    app.run()

